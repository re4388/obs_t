

Dijkstra 算法:
* 目標: 找到**一個點到其他所有點的最短路徑**
* 核心: 基於貪婪算法，每次選擇當前距離源點最近的**未訪問**節點(so need visit arr)，並更新其鄰居節點的距離。need PQ
* 適用場景:  邊的權重非負。


BFS:
* 目標:  **逐層探索圖，先訪問距離源點近的節點，再訪問距離源點遠的節點**。
* 核心: 使用佇列 (Queue) 儲存待訪問的節點。
* 適用場景:  尋找最短路徑（在邊權重相同或不重要的情況下），或者在**有步數限制**的情況下。


為什麼這題不能用 Dijkstra？
雖然 Dijkstra 算法可以找到最短路徑，但它無法處理帶有步數限制的最短路徑問題。  
Dijkstra 算法的貪婪策略會優先選擇當前最短的路徑，而忽略了步數的限制。  在 `Cheapest Flights Within K Stops` 這題中，即使一條路徑的價格較低，但如果它的經停次數超過了 `k`，它也是無效的。  Dijkstra 無法有效地處理這種限制。


為什麼這題要用 BFS？
BFS 非常適合處理步數限制的問題。  
**BFS 逐層探索圖，可以確保在探索到步數超過 `k` 的路徑之前，先探索完所有步數小於等於 `k` 的路徑**。  
這使得 BFS 可以找到符合步數限制的最便宜路徑。  在程式碼中，`curStopTime` 變數追蹤了當前的步數，`if (curStopTime > k) continue`  這行程式碼確保了只考慮符合步數限制的路徑。


如何分辨何時使用 BFS 或 Dijkstra？
1. 是否有步數限制？  **如果有步數限制，則使用 BFS**。
2. 邊的權重是否非負？  如果邊的權重可能為負，則不能使用 Dijkstra，可以考慮 Bellman-Ford 算法。
3. 是否需要找到單一源點到所有其他節點的最短路徑？  如果只需要找到到特定目標節點的最短路徑，BFS 可能更有效率。


關於程式碼中 visit 的問題：
你的程式碼中沒有使用 `visit` 陣列，這是因為 BFS 的佇列機制已經確保了每個節點只會被訪問一次（在當前步數下）。  
**由於題目要求的是在 `k` 步限制下的最短路徑，即使一個節點在之前的步數中被訪問過，在當前的步數下也可能需要再次訪問。**  
因此，不需要使用 `visit` 陣列來標記已訪問的節點。  如果題目沒有步數限制，單純求最短路徑，那麼 BFS 就需要 `visit` 陣列來避免重複訪問。


總之，在處理帶有步數限制的最短路徑問題時，BFS 比 Dijkstra 算法更合適。  
Dijkstra 算法適用於尋找沒有步數限制的一個點到所有點的最短路徑，尤其是在邊權重非負的情況下。


