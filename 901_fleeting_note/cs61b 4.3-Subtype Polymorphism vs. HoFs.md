[[CS61B Data Structures and Algorithms|cs61b_index]]
[4.3 Subtype Polymorphism vs. HOFs · Hug61B](https://joshhug.gitbooks.io/hug61b/content/chap4/chap43.html)
[(801) [Inheritance3, Video 0] Dynamic Method Selection Puzzle optional - YouTube](https://www.youtube.com/watch?v=cUL1LWVv984&list=PL8FaHk7qbOD7o8I8uundaaaHRc5zA0IjE)


# begin w/ dynamic type selection puzzle



可以這樣理解
showDog is Dog  -> imply you can assign ShowDog to Dog
Dog is Object      -> imply you can assign Dog to Object
反過來就不一定


![[CleanShot 2024-12-10 at 20.38.17.png]]



![[CleanShot 2024-12-10 at 20.33.24.png]]
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003104933862.png|882]]


showDog 可以放到 Object -> 因為規則是小可以放在大的 mem box 裡面  (小這裡是 refer to subclass,  大 refer to super class)

showDog 可以放到 showDog
第一個 sda.bark  -> showDog.bark()  since showDog have override method on bark

第二個, o2 Object type 可以 cast 為 Dog (it's okay and normal to use casting to narrow the type) 
dx.dark -> 這邊 dx 的 Dog is static type, 但是 dynamic type is ShowDog, and dynamic type selection -> 應該呼叫 showDog 的 bark

第三個，跟上面一樣 -> 呼叫 showDog 的 bark

第四個，Dog 可以 assing to Object, 小可以放到大的
o3.bark -> 最後一個會 compiler error, 
o3 無法判斷是要用那個 method 呼叫, 因為static type 是 Object,  compiler 無法判斷你要用 Dog or ShowDog



---


如果 child 有變數跟 super class 一樣的名字?
如果 child 有靜態方法跟 parent 撞名?

這堂課不深究
可以看以下網站
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003104948798.png]]




# Subtype Polymorphism (via interface inheritance)
Polymorphism: “providing a single interface to entities of different types"

就是透過 dynamic method selection 實現
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105002594.png|758]]




下面的 subtype多態的作法
more OOP
use object method to do their thing
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105002710.png|734]]


# The Max Function
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105020925.png|720]]





![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105021058.png]]

最下面的 max(dogs) return Object
object 可以 cast 為 Dog -> 這是最常見的，我們用 cast 來 縮小 type 

最上面的 函數
dogs 的 type 是 `Dog[]` 可以放到 `Object[]`嗎?
小的可以放到大的 -> 可以

中間的比大小
這個要看有沒有實作 dog 比大小，如果沒有，那就會用 object 的比大小? 是這樣用嗎? -> 不是


可以把比大小實作在 dog, like below
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105046938.png]]

一個壞處是，這樣你就變成dog有自己的比大小
更重要的是，如果你有 cat,  等等其他 class, 你全部都要實作一個新的 max code?
那如果還有算 min, 算avg, 你全部都要自己每個 class都要實作?
hense, this is not a good idea



![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105047136.png|795]]

/Users/re4388/project/personal/CS61B/lectureCode-sp19/inheritance3

![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105113473.png|509]]

![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105129036.png|864]]
PS: 作者用 uddaDog just for fun, you can just use otherDog

回到 `Maximizer` class
這邊 arg 可以吃 `OurComparable`
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105137706.png]]



也可以這樣改， code is cleaner
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105145650.png]]

![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105145825.png|450]]



![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105152707.png|624]]



缺點是...
你需要 cast obj to Dog 來比較
因此如果這邊放錯，compile 檢查不出來，然後會有 run time error
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105152859.png]]



到這邊，我們就變成只需要一個 max 函數!
只要進來的東西可以是 `OurComparable[]` type 就可以使用!
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105158747.png|804]]



# another quiz
拿掉 compareTo
哪邊會 compile fail
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105206731.png|724]]




Dog 會無法
因為 Dog 有impl OurComparable, so it will  compliant 你沒有實作 compareTo
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105206887.png|808]]


拿掉 implements Ourcomparable
哪邊會無法 compile
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105210906.png]]


DogLauncher 會無法
因為 dogs as parameter, 需要有實作 ourComparable 才可以被 Maximizer.max 吃進去。這邊compiler will detect and throw err
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105211035.png]]



Maximizer class 和 OurComparable interface work on higher level
他們可以獨立存在，未必需要有實作這個 interface 的 class 和 launcher

![[CleanShot 2024-12-10 at 21.04.19.png]]



# `ourComparable` 的問題 -> 用 `Comparable<T>`


- 需要 cast
- `ourComparable` 是我們自己建立的，so..
	- 沒有其他的 class 有去實作 `ourComparable` 
	- 沒有其他的 class 使用這個 `ourComparable` 
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105215099.png|738]]



我們應該盡量要用內建的 interface
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105218416.png]]


使用內建的，內建有泛型可以讓你用
這樣你就使用大家都用的 `Comparable<Dog>`
這樣別人也可以使用
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105222758.png]]




不需要 cast
用內建的，有其他 class 實作了，類似 String, 因此你 type 如果用 String, 就可以直接用它的 implmentation
其他 class 也使用一樣的 interface, 因此你 dogs 實例就可以被吃進去, like below (`Collection.max`)
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105222854.png]]



# Comparator

如果我們要比大小，要根據不同標準去比? (like 用 size 比，或是用 alphabetical order..等等)
可以用 HoF, pass 不同的 compare function
那 subtype多型要如何做?
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105226538.png]]


傳入 comparator
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105229836.png]]



你需要建立一個 nested class 來實作 Comparator 介面
裡面要實作 compare
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105229982.png]]


建立一個 nested static class `NameComparator`, impl `Comparator<T>`
下面的 a.name.compareTo 直接使用 String 裡面實作好的 compareTo

這裡用 static 只是讓我們好使用( class.xxx 就可以用)，另外這邊 `NameComparator` 也沒有要跟 class 其他地方的 instance method, variable 有所互動。
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105234114.png]]


![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105234241.png]]


另外，如果我們要更符合常用寫法
我們會用private
然後另一個 public method return instance 出去
![[CleanShot 2024-12-10 at 21.28.23.png|693]]
 ![[CleanShot 2024-12-10 at 21.29.18.png]]



如果你要另一個 Size比較器, 依樣畫葫蘆
![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105237205.png]]



用 interface inheritance 來做到 callback 的效果
你只要 impl A1
那 Java compiler 會知道你有 impl
因此就可以讓你使用

![[IMG-cs61b 4.3-Subtype Polymorphism vs. HoFs-20241003105237368.png]]