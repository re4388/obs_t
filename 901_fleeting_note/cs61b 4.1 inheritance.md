
[[CS61B Data Structures and Algorithms|cs61b_index]]


code: /Users/re4388/project/personal/CS61B/lectureCode-sp19/inheritance1



# override
孩子 class 有跟parent class 一樣的 method, 一樣的 param
那孩子 method 就 override parent class method

![[CleanShot 2024-12-10 at 09.14.57.png]]

加上 @Override annotation 讓 ide 幫你 check 你是否真的有進行 override 行為
![[CleanShot 2024-12-10 at 09.20.12.png]]
![[CleanShot 2024-12-10 at 09.21.09.png]]


# overload
孩子 class 有跟parent class 一樣的 method, 但是不一樣的 param

如下圖 makeNoise 是 overloaded
這邊沒有 a overload b 的概念
這邊的概念就是 這個 fn 是 overloaded
![[CleanShot 2024-12-10 at 09.17.26.png]]


overload 也可以發生在同一個 class 中的 method
![[CleanShot 2024-12-10 at 09.18.53.png]]


# interface inheritance



你只要用 implements 就是使用  interface inheritance
![[CleanShot 2024-12-10 at 09.37.37.png]]





- 下面的問題是...
	- a1 是 `AList<String>`, why pass to WordUtils.longest(a1), 但 a1 是 `List61B<String>` type? 這樣可以?
- ans:
	- parent `List61B<String>` 的 mem box 可以放 child 的 mem `AList<String>`
![[IMG-cs61b 4.1 inheritance-20241003104933846.png|715]]



問題:
new 一個 SLList 然後放到 List61B中
然後跑起來會如何
![[CleanShot 2024-12-10 at 09.44.59.png]]





Ans:
沒事，可以 compile
runtime 也沒問題
new 一個 SLList 後， mem addr 放到 someList, static type 是 List61B
因為 code 裡面有 override, 因此 dynamic type selection 優先，因此 會跑 Sllist.addFirst的實作
![[IMG-cs61b 4.1 inheritance-20241003104948785.png|750]]

# implementation inheritance: Default method


java 你可以在 interface 裡面放 impl (code)
![[CleanShot 2024-12-10 at 09.46.48.png]]



Java 有 implementation inheritance
- 你可以在 interface 裡面加上 `default` keyword, 然後如果 child 沒有 impl, 會跑這個方法
- 這個 default method 也可使用其他 interface (如果 child 有 impl, 就會用)
- 衍生問題：
	- 但是 interface 其他都沒實作，也沒 field, 如何實作?
	- ans: 如下，可以利用其他的 method 做。

![[CleanShot 2024-12-10 at 09.50.52.png|483]]


衍生問題
- `size()` and `get(i)` 會分別用child 的實作去跑
- `size()` will be fast enough
- but `get(i)` will be slow for SLList
	- since every `get(i)` invocation, it will start from linkedlist head and go thru to find i
- 這個時候，SLList 可以 override 這個 print(), 自己實作自己比較快的作法, like 直接 go thru the linked list and print one by one
![[IMG-cs61b 4.1 inheritance-20241003105019218.png|640]]

![[IMG-cs61b 4.1 inheritance-20241003105019424.png]]



# dynamic model selection
- each variable have a static and dynamic type
- like lt1
	- declare as LivingThing
	- and then new Fox() 實例 and copy the mem bit to lt1, and then lt1 have a fox dynamic type
	- last line, new Squid() does the same thing, so at the end, lt1 have a Squid dynamic type
![[IMG-cs61b 4.1 inheritance-20241003105045195.png|831]]



如果 一個 method 有不同的 靜態 type and runtime/dynamic type
如果 dynamic type 有 override, 會使用 dynamic type 的那個 method
![[IMG-cs61b 4.1 inheritance-20241003105045397.png|791]]






puzzle of overload
peek(SP) -> SP 動靜態type都是 SLList -> `elk`
peek(LP) -> LP 靜態是 List61B, 動態是 SLList -> 我猜是 用動態 -> elk -> 錯！ 這是 overload, 不是 override
overload 你看下面兩個 peek 是不同的 param
因此你丟 peek(LP) , LP 的 type 是 List61B -> 因此呼叫 上面那個 peek -> `cool`
![[CleanShot 2024-12-10 at 14.34.38.png]]


dynamic model selection only for override
![[CleanShot 2024-12-10 at 14.54.24.png]]




最後一個比較 tricky
a is Animal static type and Dog dynamic type
都有 flatter
但是他們吃的 signature 不同
如果 signatrue 不同，就進入 overload 的判斷優先，以 static type為主
因此這邊會使用 Animal 的 method


![[IMG-cs61b 4.1 inheritance-20241003105111736.png|745]]

```java

public class Run {
    public static void main(String[] args) {
        Animal a = new Dog();
        Dog d = new Dog();

        a.greet(d); // hello animal, Dog class doesn't have greet method, it's inherited from Animal
        a.sniff(d); // Dog sniff animal, use `dynamic type selection` to call Dog's(dynamic type) sniff method
        d.flatter(d); // u r cool dog,  static and dynamic type both are Dog, use Dog's flatter method
        a.flatter(d); // u r cool animal,
    }
}

```


# 小心使用 imple inheritance
![[IMG-cs61b 4.1 inheritance-20241003105112123.png|724]]




# Summary


interface inheritance
例子:
code: /Users/re4388/project/personal/CS61B/lectureCode-sp19/inheritance1
只要A, B, C, D都實作同一個 interface
那如果有一個函數X吃這個 interface 去
那這個函數X 就可以吃 A, B, C, D
之後你做到的 E, F, G, 只要你也是符合/實作這個 interface
函數X吃下 E, F, G 的 type

![[IMG-cs61b 4.1 inheritance-20241003105127946.png|690]]


