[[CS186 Introduction to Database System]]

# abstract process order
- you can read sql in this order
		![[IMG-186-03-sql2-20241003104933535.png]]
```sql

SELECT S.dept, AVG(S.gpa), COUNT(*) 
FROM Students S
WHERE S.gender = 'F'
GROUP BY S.dept  
HAVING COUNT(*) >= 2
ORDER BY S.dept;


```

In natural lang:
get from student table
where I only get the female rows
and I want to group by dept, and filter by group count >= 2
I want to show dept, avg of each dept's gpa and each dept's ppl number
finally I want to order by dept by counts


![[CleanShot 2024-11-03 at 20.41.17.png]]


- `from <table list>` -> cross-prod of many table


where 是撈 row/recrod
select 是撈 col
![[IMG-186-03-sql2-20241003104948726.png]]


- alias also let you self-join
- expression can at select clause and in where clause
```sql

SELECT S1.sname AS name1, S2.sname AS name2
FROM   Sailors AS S1, Sailors AS S2
WHERE  2*S1.rating = S2.rating - 1

```

# string comparision

```sql

-- Old School SQL
SELECT S.sname
FROM   Sailors S
WHERE  S.sname LIKE 'B_%’


-- Standard Regular Expressions

SELECT S.sname
FROM   Sailors S
WHERE  S.sname ~ 'B.*’

```


# `union all` and `intecsec`


these are equivalent
```sql


SELECT R.sid
FROM Boats B,Reserves R
WHERE R.bid=B.bid AND 
(B.color='red’ OR B.color='green')
 

上面和下面一樣

SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='red'

UNION ALL
 
SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='green'

```


there are NOT equivalent
```sql

SELECT R.sid
FROM Boats B,Reserves R
WHERE R.bid=B.bid AND 
(B.color='red’ AND B.color='green')
--> this is not possible to have a boat both have red and green in the same time

VS…

SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='red'   -> 預訂紅色船的所有水手 ID。

INTERSECT

SELECT R.sid
FROM Boats B, Reserves R
WHERE R.bid=B.bid AND B.color='green' -> 預訂綠色船的所有水手 ID

-> this is possible, 找出同時出現在兩個結果集中的水手 ID，也就是同時預訂了紅色和綠色船的水手
```


assume
**A:** (Jim, 18, English, 4.0) 
**B:** (Marcela , 20, CS, 3.8)
**C:** (Gail, 19, Statistics, 3.74)
**D:** (Goddard, 20, Math, 3.8



![[IMG-186-03-sql2-20241003104959562.png]]

![[IMG-186-03-sql2-20241003104959661.png]]


![[IMG-186-03-sql2-20241003105015683.png]]


# nested query

```sql


IN
- _Names of sailors who’ve reserved boat #102:_
SELECT S.sname
FROM   Sailors S
WHERE  S.sid IN 
(SELECT  R.sid
FROM    Reserves R
WHERE   R.bid=102)




NOT IN

- _Names of sailors who’ve_ **_not_** _reserved boat #103_
SELECT  S.sname
FROM  Sailors S
WHERE  S.sid NOT IN 
(SELECT  R.sid
FROM  Reserves R
WHERE  R.bid=103)



EXISTS
- _This is a bit odd, but it is legal:_
SELECT  S.sname
FROM  Sailors S
WHERE  EXISTS
(SELECT  R.sid
FROM  Reserves R
WHERE  R.bid=103)


Correlated subquery is recomputed for each Sailors tuple.
- _Names of sailors who’ve reserved boat #102:_
SELECT  S.sname
FROM    Sailors S
WHERE EXISTS
(SELECT  *
FROM  Reserves R
WHERE R.bid=102 AND S.sid=R.sid) -> each s.sid will run the subquery, 100 sid will run 100 times



More on set-comparision oprator
- We’ve seen: IN, EXISTS
- Can also have: NOT IN, NOT EXISTS
- Other forms: op ANY, op ALL





Find sailors whose rating is greater than that of _some_ sailor called Popeye:

SELECT *
FROM   Sailors S
WHERE  S.rating > ANY 
(SELECT  S2.rating
FROM  Sailors S2
WHERE S2.sname='Popeye')

```



# this one is tricky: Relational Division

“Find sailors who’ve reserved all boats.” 
Said differently: “sailors with no counterexample missing boats”

水手預約了所有的船
或是說，不存在這種水手沒有預約的船
```sql

SELECT S.sname
FROM Sailors S
WHERE NOT EXISTS (
	SELECT B.bid
	FROM Boats B 
	WHERE NOT EXISTS (
		SELECT R.bid
		FROM Reserves R
		WHERE R.bid=B.bid
		AND R.sid=S.sid ))

```


# ARGMAX
找出某個col最大的那個or多個rows
```sql

SELECT MAX(S.rating) 
FROM Sailors S;
-- not useful, only get a single value

SELECT S.*, MAX(S.rating)
FROM Sailors S;
-- not legal ops in sql -> max by what? you need to have group by something or a defined set to max


SELECT *
FROM   Sailors S
WHERE  S.rating >= ALL    -- where rating is >= All rating
(SELECT  S2.rating        -- get all rating
FROM  Sailors S2)
-- correct


SELECT *
FROM   Sailors S
WHERE  S.rating =         -- show those data where rating equal to the max rating
(SELECT  MAX(S2.rating)   -- find the max rating
FROM  Sailors S2)
-- correct


SELECT *
FROM   Sailors S
ORDER BY rating DESC
LIMIT 1;
-- can be NOT correct if there's more than one ppl at highest rating, the result is not determintic

```



# join

this are the same
```sql


SELECT s.*, r.bid 
FROM Sailors s, Reserves r
WHERE s.sid = r.sid AND ...

SELECT s.*, r.bid 
FROM Sailors s INNER JOIN Reserves r 
ON s.sid = r.sid WHERE ...




SELECT _<column expression list>_
FROM _table_name_
[INNER | NATURAL  
 | {LEFT |RIGHT | FULL } {OUTER}] JOIN _table_name_
ON _<qualification_list>_
WHERE …




- INNER is default

```



natual will automatically find all matching col name and join via them
not use natural since when you create, remove col.. it might create unpredictable result
```sql

SELECT s.sid, s.sname, r.bid
FROM Sailors s, Reserves r
WHERE s.sid = r.sid
AND s.age > 20;	


SELECT s.sid, s.sname, r.bid
FROM Sailors s INNER JOIN Reserves r
ON s.sid = r.sid
WHERE s.age > 20;



SELECT s.sid, s.sname, r.bid
FROM Sailors s NATURAL JOIN Reserves r WHERE s.age > 20;


ALL 3 ARE EQUIVALENT!
“NATURAL” means equi-join for pairs of attributes with the same name

```

left outer, right outer, full outer -> see ptt



# view
save the query syntax, not cache the result
```sql

CREATE VIEW  view_name
AS select_statement
Makes development simpler
Often used for security

-- Not “materialized”


CREATE VIEW Redcount
AS SELECT B.bid, COUNT(*) AS scount
FROM Boats2 B, Reserves2 R
WHERE R.bid=B.bid AND B.color='red'
GROUP BY B.bid

```


subquery and CTE are like "view in the fly"
CTE is like flattern of subquery


subqurry
```sql

SELECT  bname, scount
FROM Boats2 B, 
	(SELECT B.bid, COUNT (*)
	FROM Boats2 B, Reserves2 R
	WHERE R.bid = B.bid AND B.color = 'red'
	GROUP BY B.bid) AS Reds(bid, scount)
WHERE  Reds.bid=B.bid
AND scount < 10



```


CTE
```sql

WITH Reds(bid, scount) AS (SELECT B.bid, COUNT (*)
FROM Boats2 B, Reserves2 R
WHERE R.bid = B.bid AND B.color = 'red'
GROUP BY B.bid)


SELECT bname, scount
FROM Boats2 B, Reds
WHERE Reds.bid=B.bid
AND scount < 10


-- another ex

WITH Reds(bid, scount) AS (SELECT B.bid, COUNT (*)
FROM Boats2 B, Reserves2 R
WHERE R.bid = B.bid AND B.color = 'red'
GROUP BY B.bid),

UnpopularReds AS SELECT bname, scount
FROM Boats2 B, Reds
WHERE Reds.bid=B.bid
AND scount < 10


SELECT * FROM UnpopularReds;



-- another ex to get argmax

WITH maxratings(age, maxrating) 
AS (SELECT age, max(rating) 
FROM Sailors
GROUP BY age)


SELECT S.*
  FROM Sailors S, maxratings m
 WHERE S.age = m.age
   AND S.rating = m.maxrating;

```

# null

Rule: (x op NULL) evaluates to … NULL!
SELECT 100 = NULL;
SELECT 100 < NULL;
SELECT 100 >= NULL;


null check
SELECT * FROM sailors WHERE rating IS NULL;
SELECT * FROM sailors WHERE rating IS NOT NULL;


Rule: Do not output a tuple  WHERE NULL
SELECT * FROM sailors;  -> include null record
SELECT * FROM sailors WHERE rating > 8;  -> not include null reocrd
SELECT * FROM sailors WHERE rating <= 8; -> not include null reocrd





![[IMG-186-03-sql2-20241003105041990.png]]
SELECT * FROM sailors WHERE rating > 8 AND TRUE;  -> Null  AND TRUE ->  Null 
SELECT * FROM sailors WHERE rating > 8 OR TRUE;  -> Null OR TRUE -> TRUE 
SELECT * FROM sailors WHERE NOT (rating > 8);   -> NOT Null -> Null


General rule: NULL **column values** are ignored by aggregate functions

```sql


SELECT count(*) FROM sailors;  -> 會包括 null
SELECT count(rating) FROM sailors;  -> 不會包括 null
SELECT sum(rating) FROM sailors;    -> 不會包括 null
SELECT avg(rating) FROM sailors;    -> 不會包括 null


```



小結
- NULL op NULL is NULL
- WHERE NULL: do not send to output
- Boolean connectives: 3-valued logic
- Aggregates ignore NULL-valued inputs