[[CS61B Data Structures and Algorithms|cs61b_index]]

# 使用 extends

`RotatingSLList` extends and have a noew method `rotateRight`

![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003104933851.png|763]]


用 extends 可以拿到 parents 的所有東西
variable, static, nested class 等等
只有 ctor 沒有繼承 (hense 要用 super)
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003104948790.png|694]]




`VengefulSLList` `extends` `SLList` 可以記錄移掉的 item
使用 SLList 的 remvoeLast 來記錄 via `super`
and add some code to have the record `functionality`

PS: remember to new up a SLList when declare the variable OR in ctor
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105002267.png]]


# ctor 預設行為


ctor 不會 ihherited -> need to call super
java will auto call super if you didn't write it
if the parent class have 2 ctor -> it will use the default one, which is the one do not take the argument
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105002378.png|774]]


So, you need to use `super(x)` if you don't want the default behavior  (which use the no-arg ctor in parent)
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105019983.png|792]]


# object class
every type in Java 都是 `Object` class 的 child
interface 不是
你自己寫的 extends 出來 就不是 Object 的 child，是 parent 的 child
but the parent is the child of the `Object`


Object class is a concrete class -> meaning it have some default method to use
一些常用的包括
compare
equals
hashCode
toString 等等
[Objects (Java Platform SE 8 )](https://docs.oracle.com/javase/8/docs/api/java/util/Objects.html)
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105045712.png|704]]



reminder again! use `extends` only when the relationship is `is-a`
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105045927.png|687]]



# Encapsulation to handle complexity

 handle 複雜度的方法
 - 建立抽象，封裝實作
	 - 每一層抽象都要藏的好，hide details
 - 設計要考慮好擴展
 - 讓 object decided what to do
 - OOP
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105112773.png|740]]


![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105113086.png|730]]


一些學生的問題
ANS?
-> 盡量盡量不要去 dig/peak private 的東西
-> test it using its interface
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105128427.png|835]]

![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105128707.png|843]]




# implementation inheritance 的 問題


Beware!
改了 VerboseDog, 沒改 Dog -> infinite loop 
-> impl inherit 可以有 default -> 但小心有這個問題
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105137596.png|772]]


這樣寫就不會有infinite loop了
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105137793.png|739]]






# Type Checking and Casting

![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105145719.png|698]]



如果有 override, 使用 動態 instance
(這邊要看code才好理解, pwd: /Users/re4388/project/personal/CS61B/lectureCode-sp19/inheritance2)

if you check code..
you will see removeLast SLList 有，然後 VengefulSLList 也有且 overriden
then, addLast 只有 SLList 有, VengefulSLList 沒有


![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105152600.png|814]]


`sl.printLostItems()`
- 因為 `sl` 的 static type 是 `SLList`, 呼叫 `VengefulSLList` 的方法，compile error
`VengefulSLList<Integer> vs12 = sl`
- 就算你把 sl assign 到另一個 variable, 然後你給他 child 的 type, compile error
- 因為 compile play safe, 這樣有可能是動態或是靜態，play safe -> err
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105158449.png|730]]



child can put into parent's mem box
BUT
parent can not put into child mem box

![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105158589.png|749]]


method 會定義 return type, a static type
this shall match when you assign to another type

下面
maxDog is child of Dog -> compile ok
maxDog (雖然吃兩個 Poodle) 要 assign 到 Poodle 
-> 靜態 type 是 Dog, Dog 是大的 -> assign 到小的 -> not allow
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105206613.png|782]]



如果硬要解 -> casting
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105210587.png|711]]



下面是一個 casting 來告訴 compiler this is okay -> BUT run time error 的例子
Malamute 是 dog, 因此可以吃進去 maxDog, 但是下面 cast to Poodle..
因此當你使用 frankSr 的 method 時，就會出現 run time error 了
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105210714.png|793]]

```java

Poodle frank = new Poodle("Frank", 5);
Malamute frankSr = new Malamute("Frank Sr.", 100);

Poodle largerPoodle = (Poodle) maxDog(frank, frankSr); // runtime exception!

```



impl 繼承的 cheatsheet
![[IMG-cs61b 4.2- Extends, Casting, Higher Order Functions-20241003105222490.png|768]]


# high order fn (HoF) in Java

if we have fn-ptr, we use use arg to pass fn
BUT, before Java7(也包括 java7), variable can not put fn-ptr


python 可以這樣寫
![[CleanShot 2024-12-10 at 19.26.08.png]]



java 要利用 interface inheritance
![[CleanShot 2024-12-10 at 19.26.32.png]]

建立 interface: IntUnaryFunction
```java 

public interface IntUnaryFunction {
    int apply(int x);
}

```


建立 tenX, 實作 IntUnaryFunction, apply 裡面實作邏輯, 這邊是 10 * x
```java

public class TenX implements IntUnaryFunction {
    /**
     * Returns ten times the argument
     */
    public int apply(int x) {
        return 10 * x;
    }
}


```


HoFDemo
```java

public class HoFDemo {

    // do_twice can accept any type that implement IntUnaryFunction interface
    public static int do_twice(IntUnaryFunction f, int x) {
        // 這邊也包了兩層， like f(f(x))
        return f.apply(f.apply(x));
    }

    public static void main(String[] args) {
        // 我們可以 get intsance from TenX class which implement IntUnaryFunction
        IntUnaryFunction tenX = new TenX();

        
        int res = do_twice(tenX, 2)
        System.out.println(res);
    }
}


```
