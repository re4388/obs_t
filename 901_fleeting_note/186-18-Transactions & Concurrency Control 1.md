[[CS186 Introduction to Database System]]



下面開始會討論 db 如何確保 isolation, "I" of AC"I"D
![[IMG-186-18-Transactions & Concurrency Control 1-20241003104933617.png|653]]


![[IMG-186-18-Transactions & Concurrency Control 1-20241003104948741.png|692]]


![[IMG-186-18-Transactions & Concurrency Control 1-20241003105000028.png|735]]

## what is 可序列化?
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105016411.png|504]]
**定義：** 如果一個排程 S 等價於某個串列排程，則稱 S 是可序列化的。



- **例子：** 兩個交易 T1 和 T2，分別是轉帳 $100 和增加 10% 利息。



![[IMG-186-18-Transactions & Concurrency Control 1-20241003105016541.png|681]]
- **Schedule 1:** T1 先執行，然後是 T2，這是一個串列排程，也是基準。


![[IMG-186-18-Transactions & Concurrency Control 1-20241003105042756.png|700]]
- **Schedule 2:** T2 先執行，然後是 T1，這也是一個串列排程，但結果與 Schedule 1 不同。

這個例子很有趣，就算是串列，也會因為資料邏輯上的關係，導致出現可能你不要的結果
如果這邊是你要先＋-  和乘 的順序是定序的，這兩個 tx 就要包起來一個 tx



![[IMG-186-18-Transactions & Concurrency Control 1-20241003105105205.png|713]]
- **Schedule 3:** T1 和 T2 的操作交錯執行，這不是串列排程，但最終結果與 Schedule 1 相同，因此是可序列化的。




**衝突可序列化性 (Conflict Serializability)** 是一種用於判斷並行資料庫交易排程是否正確的方法。

**基本概念：**

* **交易 (Transaction):** 一組資料庫操作，被視為一個單一的邏輯單元，必須全部執行或全部不執行。
* **排程 (Schedule):** 多個交易的操作按時間順序排列的序列。
* **衝突操作 (Conflicting Operations):** 來自不同交易的操作，如果它們訪問相同的資料項，並且至少其中一個是寫操作，則它們是衝突的。例如，兩個交易都訪問資料項 A，其中一個交易要寫入 A，則它們的操作是衝突的。

**衝突可序列化性：**

如果一個排程可以通過交換**不同交易**的**連續非衝突操作**，轉換成一個串列排程，那麼這個排程就是衝突可序列化的。

**直觀理解：**

想像一下，有兩個交易 T1 和 T2，它們都包含一些讀取 (R) 和寫入 (W) 操作。如果我們可以通過調整 T1 和 T2 中非衝突操作的順序，使得最終結果等同於先後執行 T1 和 T2，那麼這個排程就是衝突可序列化的。

**重要性：**

* **保證資料庫一致性：** 衝突可序列化性確保了並行執行的交易不會導致資料庫處於不一致的狀態。
* **簡化並行控制：**  它提供了一種相對簡單的方法來判斷一個排程是否正確，從而簡化了並行控制的設計和實現。

**限制：**

* **保守性：** 衝突可序列化性是一種保守的測試，可能會將一些實際上可序列化的排程判斷為不可序列化，從而降低了並行度。

**總之，** 衝突可序列化性是一種用於確保並行交易正確性的重要概念，它通過限制衝突操作的順序來保證資料庫的一致性。 




## 衝突操作與衝突可序列化排程

![[IMG-186-18-Transactions & Concurrency Control 1-20241003105125707.png|541]]
* **問題：** 直接檢查「是否讓資料庫處於相同最終狀態」來判斷可序列化性很困難。
* **解決方案：** 需要一個更簡單的等價性測試方法。
* **折衷方案：** 採用一種「保守的」測試方法，它能保證所有判斷為可序列化的排程都是正確的 (true positives)，但可能會將一些實際上可序列化的排程判斷為不可序列化 (false negatives)。
    * 換句話說，為了更容易地檢查正確性，犧牲了一些並行性。
* **衝突操作：** 引入「衝突操作」的概念，即讀寫操作。
* **定義：** 兩個操作如果滿足以下全部條件，則它們衝突：
    * 來自不同的交易
    * 操作同一個物件
    * 至少其中一個是寫操作
* **重點：** 非衝突操作的順序不影響資料庫的最終狀態，因此我們只需要關注衝突操作的順序。



![[IMG-186-18-Transactions & Concurrency Control 1-20241003105135460.png|490]]
* **定義：** 如果兩個排程滿足以下條件，則它們衝突等價：
    * 它們包含來自相同交易的相同操作
    * 每對衝突操作的順序都相同
* **定義：** 如果排程 S 衝突等價於某個串列排程，則稱 S 是衝突可序列化的。
    * 這意味著 S 也是可序列化的。
* **注意：**
    * 一些可序列化的排程**不**是衝突可序列化的。
    * 作為可序列化性的測試，衝突可序列化性會產生誤判 (false negatives)。
    * 這是為了實現高效的強制執行而付出的代價，是一種保守的測試方法。

**總結：**
衝突操作和衝突可序列化性提供了一種更易於檢查的可序列化性判定方法，雖然它是一種保守的測試，可能會犧牲一些並行性，但它更容易實現，並且在很多情況下都能有效地保證資料庫的一致性。




![[IMG-186-18-Transactions & Concurrency Control 1-20241003105144001.png|607]]


![[IMG-186-18-Transactions & Concurrency Control 1-20241003105151226.png|585]]

可以交換，因為不同, 一個 A 一個 B 
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105157164.png|597]]


可以交換，since 1 A 1 B
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105202144.png|598]]


the same, 1 A, 1B, both also read
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105202257.png|631]]


one is W, but 1 A 1 B
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105209625.png|613]]


both A and both W, can not swap
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105213757.png|593]]
## View Serializability 視圖可序列化性
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105217051.png]]

**視圖可序列化性 (View Serializability)**，它是一種比 **衝突可序列化性 (Conflict Serializability)** 更寬鬆的並行控制準則。

**主要內容：**

* **視圖可序列化性是另一種判斷可序列化性的方法，它能減少誤判 (false negatives)。** 
    * 誤判指的是系統將實際上可序列化的排程判斷為不可序列化。
* **如果兩個排程 S1 和 S2 滿足以下條件，則它們視圖等價：**
    * **相同的初始讀取：** 如果交易 Ti 在 S1 中讀取了資料 A 的初始值，那麼它在 S2 中也必須讀取 A 的初始值。
    * **相同的依賴讀取：** 如果交易 Ti 在 S1 中讀取了由交易 Tj 寫入的 A 值，那麼它在 S2 中也必須讀取由 Tj 寫入的 A 值。
    * **相同的最終寫入：** 如果交易 Ti 在 S1 中寫入了 A 的最終值，那麼它在 S2 中也必須寫入 A 的最終值。
* **基本上，視圖可序列化性允許所有衝突可序列化的排程，再加上「盲寫 (blind writes)」。**
    * 盲寫指的是一個寫入操作不會影響到其他交易的讀取操作。

**圖示說明：**

圖中展示了兩個視圖等價的排程。

* 左側的排程中，T1 讀取了 A 的初始值，然後 T2 和 T3 依次寫入了 A。
* 右側的排程中，T1 仍然讀取 A 的初始值，但 T2 和 T3 的寫入順序交換了。
儘管兩個排程的寫入順序不同，但它們都滿足視圖等價的條件，因此都是視圖可序列化的。

**總結：**

視圖可序列化性提供了一種更靈活的並行控制方法，它允許更多合法的排程，同時仍然保證資料庫的一致性。 




- 視圖可序列化性 效率會較低
- 不管是哪一種可序列化判斷都不是真正意義上的可序列化，因為他們無法了解實際操作上的資料意義
	- 例子，上面先乘後加 vs 先加後乘
![[IMG-186-18-Transactions & Concurrency Control 1-20241003105217141.png|666]]