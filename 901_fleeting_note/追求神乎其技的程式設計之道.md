[[0_career_idx]]


# 如何區別一般和高手 programmer？
   1. 普通 programmer 犯了這種錯會覺得很平常，並提醒自己下次別再這麼笨了，但不久後一定又會再犯同樣的錯；厲害的 programmer 會反省自己寫程式的方法，並改變原有的方法或習慣來避免以後再度產生同樣的 bug。[[不要犯重複的錯誤]]



# 一定程度的壓力和競爭是進步的必要條件 [[要有壓力才會學好]]
   1. 參加比賽是一個評估自己實力的好方法，沒在比賽會場上較勁過，真的很難體會解題與寫程式能力的差距可以有多麼巨大。
   2. 一個頂尖的程式設計師和一個普通的程式設計師，其生產力是很輕易的能有十倍甚至百倍以上的差距，而寫出來的程式碼品質及效率也是同樣會有如此巨大的落差
   3. 透過良性的競爭，高中這段時間也成了我進步最快的一個時期


# 反覆的看到林，鑽研樹，重覆見樹又見林的過程。
   1. 台灣的教育方法是「先見樹，再見林」，也就是先教你細部的方法和技術，等你都學會之後（或是硬背起來之後），出社會後就會知道為什麼要學這些東西。（很多人小時候都聽過「等你長大就知道唸書有多重要」吧。可是現在比較多人畢業後反而說「我不知道之前念那麼多書有什麼用」
   2. 在這種體制之下，許多人在還沒見到整片森林的美景前就被一棵棵大樹搞得暈頭轉向，痛苦萬分，在不知道「學了這個可以做什麼」的情況下，不管學什麼都會覺得沒有意義沒有動力。
   3. 而「見樹又見林」的學習方式，是先找到能引起自己興趣的目標，讓自己有個理由去認真學習，之後再往細部的技術和理論去學習。
   4. 我從小就很想自己寫遊戲，為了達成這個目標，我就四處尋找相關的資料，慢慢的我就知道自己應該要學好一個快速的低階語言（像是 C++），如果要寫繪圖引擎可能還得學一點圖學的理論和技術，如果要做網路連線還得學網路相關的技術…。
   5. 這裡有個重點是，不要看過森林後就忘記它，而又迷失在幾棵樹幹上，要讓自己一直重複見樹又見林的過程。
   6. 厲害的高手都很善於切換自己思考的高度
   7. 一下能跟你討論高階的系統架構設計，一下又能深入到最底下的組合語言和二進位除錯。
   8. 他們腦中除了有這高塔每一層的詳盡平面圖，甚至也非常了解不同樓層之間的交互關係。
   9. 而平凡的程式設計師大多只能專注於自己所開發的範圍，對於其上的架構或其下的細節都不一定能理清頭緒，萬一出現 bug 也會搞不清楚到底是哪一層出了錯，而被完全無關的細節絆住手腳。


# 學不同語言范式可以增加自己抽象思考的工具
   1. 這就是一個被程式語言限制住的典型例子。在高階語言用 map 存東西實在太容易了，所以這會變成思考時的一個小單位，跟人溝通或是規劃架構時都能隨時拿來用。
   2. 但相反地，在低階語言裡，要有效率又簡單的儲存這種對應關係實在很麻煩，所以人們在思考時會傾向選擇容易的方法來做，而自然忽略掉了以 map 為基礎的解決方法。
   3. related: [[尋找不變性和建立連結]]

# 對自己的工作有沒有熱情和堅持？
   1. 很可惜的是，很多人上了大學終於學會寫程式後，創意和熱情也被磨損的差不多了；
   2. 而畢業後雖然已經有了基本功力，但卻只能照著老闆開的規格刻畫死板的功能與介面，與其說是程式設計師不如說是程式工匠。
   3. 媒體工作者在報導中任意抄襲及轉載是種不尊重自己專業的表現，不但隱含著一種應付了事的心態，更代表著這些人對於自己的工作沒有熱情，更沒有著一點堅持。如果要說我在美國看到這邊和台灣有什麼最大的不同，我想關鍵的差異就在對自己的工作有沒有熱情和堅持而已了。


# 紮實的內功和熟悉系統底層的基本武功帶給我非常有效率的實做能力
- [[learn_low_level]]
   1. 我可以在想出新的 idea 的同時馬上勾勒出實做上大大小小的細節；我可以很快設計出核心的高效率演算法，也知道系統各部份的功能有什麼現有的 library 或系統可以利用，這兩種能力讓我能快速完成 prototype。我只怕沒有夠好的點子，完全不會擔心是不是真的能做得出來。
   2. web 程式所牽扯到的實做細節就多如牛毛，如果要在完全沒有穩固基礎的情況下同時學這麼多東西，只要一旦出現問題，一個對系統從上到下每個環節都不熟悉的人是完全沒辦法鎖定問題發生點的。而 debug 的基本概念就是要先鎖定問題發生的地方，要做到這件事的先決條件就是要很有信心的先排除一些不可能的地方，再做些假設並驗證假設是否成立來判斷可能問題。如果對每個環節都沒有充分的經驗，我不覺得這樣的人有能力清楚的定位出問題所在，更別提是否能獨力完成一個像樣的完整系統。
   3. 每個人都聽過成功是一分的天才加上九十九分的努力，如果說天才是能想出絕妙 idea 的能力，那我覺得還有個關鍵是，要在有點子前先做過夠多的努力打好基礎，等到靈光一現時才能把握住機會馬上實現它。如果等到一分的天才出現時，才準備開始做九十九分的努力，那很容易就會被許多基礎能力不足所帶來的挫折感和障礙所壓垮。
   4. 回想起年輕時的瘋狂，真是覺得很不可思議。如果我當時沒有堅持自己的想法，而依照爸媽的意思「好好唸書」，我想現在的我一定過著完全不同的人生，至少不太可能憑聯考進入台大資訊系，而現在也不會在 MIT 了..


# 優化自己的工具
   1. 程式設計師和其他行業有個很大的不同點：一般行業只能在現有的工具上磨練自身的技術，但程式設計師除了磨練技術外，還可以獨自創造、修改自己使用的工具
      1. [[禪與摩托車維修的藝術 Zen and the Art of Motorcycle Maintenance]]
         1. 裡面提到，使用的工具影響到自己是否可以進入心流
         2. 如果工具不好，也會讓人焦慮
         3. 厲害的 coder, 甚至要自己建立工具給自己用
   2. 換句話說，程式設計師的能力就是在電腦上創作出更好的軟體，不但能便利他人，也同時能增進自身使用電腦的工作效率。
   3. 我們只靠一台電腦就能工作，我們的工具是軟體，我們的產出也是軟體，我們的所依賴的一切都是軟體，只要自己願意投入心力，隨時可以修改每天使用的工具和系統讓自己更有效率的工作。
   4. 這一點可以說是程式設計師的先天優勢，也是頂尖的程式設計師和普通程式設計師的生產力差距的關鍵。
   5. 程式設計師每天都用電腦在工作，尤其做一個系統時常常需要花時間做一些瑣碎的工作，像是編輯設定檔、把一些檔案搬來搬去、重開伺服器、清除暫存檔…等等。這些工作通常不難，但可能步驟繁雜，或是每個步驟都要等待它慢慢完成，累積起來每天就很容易浪費許多時間手動做這些無趣的事情上。
   6. 出於「懶惰」的美德，頂尖的程式設計師工作時想的不只有產出最終產品就好，而是如何花最少力氣最少時間把產品做到最好。但這件事說來容易做來難，能不能實行往往跟程式設計師工作的系統環境有很大關係。
   7. 我跟一些人聊過這個想法，但典型的反應是「正事都做不完了，哪裡有時間先做一個工具？」但我覺得很諷刺的是，正是因為抱持這種觀念才會讓生產力低落，所以讓正事做不完，時間越緊迫就越不敢花時間做這種沒有立即產出的事情。相反地，如果在意識到自己已經三番兩次手動重複執行同樣的冗長工作時，就應該靜下來好好想想是不是有什麼辦法可以讓電腦來做這些事，只要常有這種想法，寫這些 script 和小工具所節省下來的時間和自己得到的經驗是一輩子都用得上的。
   8. 如果持續抱持著這種態度寫程式，說不定你我也能成為下一個 Knuth 呢? (笑)


# 大量練習是很重要的
9. 每個人會拿到一疊數學題目，每一面都有數個計算問題，像是「10 x 2 = ?」這樣的問題。每次去功文的任務就是把那一疊題目寫完，寫得越快的人就可以越早回家。
10. 功文數學的這套方法對訓練計算能力而言很有幫助，因為計算就是需要大量的練習才能變快變好。但問題是，計算能力再好，也是只能算已經定義清楚的問題（也就是考卷上的問題），而無法發現新問題並定義問題，更糟的是還會讓人習慣在沒有完全理解背後的概念時只學得方法快速得到答案。
    1. [[一萬小時]]
    2. [[刻意練習 -> 刻意遊戲|deliberate_play]]
    


# 看到脈絡，看到設計的演進
1. 設計師對四周環境和日常生活很敏感，常常得在生活中注意各種細節的不完美之處。
2. 但工程師成天泡在電腦中，而且很善於使用其實很難用的介面和程式（像 Linux、vi、command line、還有各種程式語言），甚至引以為傲，日子久了也就不覺得這些東西有什麼問題。泡在程式碼中的工程師也一樣，如果習慣了和前人或其他人的大便碼相處，久了也就不覺得臭了。
3. 發現這些現象後，我開始學著跳脫出原本習慣的一切，開始注意生活周遭的各種細節，思考為什麼這個東西當初要這樣設計、這樣做有什麼好處和壞處、有沒有更好的方式之類的問題。
4. 之後，當我習慣觀察細節後，慢慢察覺到我習慣用的軟體、工具、環境、程式語言，處處都是設計後的結果，而且充滿可以改進和創新的空間。這些東西都不是沒來由的產物，而是經過某些人思考過後的結果，甚至是經過好幾輪的演化結果。
5. 可惜平常在學習或教學的時候，很少人會提到這些歷史淵源和演化過程，以至於這些設計都變成理所當然的存在。但如果我們能仔細觀察平常的事物，進一步思考就會發現很多設計都是為了因應當初時空環境的限制，而這些限制現在不一定存在了，所以我們就會有發揮的空間
6. related:
   1. 程式設計的核心觀念: [[decouple]]
7. 找出影響最大的問題
    1. 眼光拉遠後，能看到的問題更多了。到了這個階段，能力強的人會覺得能解決的問題也很多。
    2. 但上天給每個人的時間是一樣多的，這時重要的事情反而又變成：「找出最重要、最根本的問題來解決，而不要被眾多的小問題和小機會所分心，才能產生最大的影響力」。
8. 學習過程的每一個階段都要是一個穩固的基石
    1. 回顧我的學習過程，我會覺得每一個階段都是一塊基石，一塊塊往上疊以後才會具備該有的能力和經驗做下一階段的事情。
    2. 舉例來說，要是我一開始沒投入程式比賽的練習累積足夠的實作能力，之後我就沒辦法隨心所欲的寫出我想寫的程式，也沒辦法參加科展體會做沒人做過的事有多麼有趣。之後我可能就會一昧沉浸在鑽研各種流行技術中，或是眼高手低說得一嘴好主意但卻做不出什麼來。
    3. 雖然學習是一步一步往上走的，但過程中每件事都有反面的效應，讓我不知道是不是做別的選擇會更好。
       1. 像是我覺得功文數學浪費了我太多時間在數學計算上，而限制了我在其他方面的發展，但同時它也讓我養成靠自己學習的習慣；參加程式競賽也有類似的效應，雖然增強了我的程式能力，但也讓我錯過正常的高中生活和課程
    4. related: [[用不到還要學嗎？]]



ref: [](https://vgod.medium.com/%E8%BF%BD%E6%B1%82%E7%A5%9E%E4%B9%8E%E5%85%B6%E6%8A%80%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E4%B9%8B%E9%81%93-2022%E9%87%8D%E7%B7%A8%E7%89%88-7cccc3c68f1e)[https://vgod.medium.com/追求神乎其技的程式設計之道-2022 重編版-7cccc3c68f1e](https://vgod.medium.com/%E8%BF%BD%E6%B1%82%E7%A5%9E%E4%B9%8E%E5%85%B6%E6%8A%80%E7%9A%84%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E4%B9%8B%E9%81%93-2022%E9%87%8D%E7%B7%A8%E7%89%88-7cccc3c68f1e)
