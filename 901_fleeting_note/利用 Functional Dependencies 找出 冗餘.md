## 例子：

假設我們正在設計一個簡單的資料庫來儲存員工信息

其中包含員工編號 (EmpID)、員工姓名 (EmpName)、部門 (Dept) 和部門負責人 (DeptManager)。

我們設計的關係表 `員工` 如下：

| EmpID | EmpName | Dept | DeptManager |
| ----- | ------- | ---- | ----------- |
| E1    | 张三      | 销售部  | 李四          |
| E2    | 王五      | 销售部  | 李四          |
| E3    | 赵六      | 研发部  | 王七          |

**分析函数依赖：**
* **EmpID → EmpName:**  每個員工編號唯一確定一個員工姓名。
* **EmpID → Dept:**  每個員工編號唯一確定一個部門。
* **Dept → DeptManager:**  每個部門唯一確定一個部門負責人。


**更新異常：**
現在，如果我們想要更新李四的部門，從 销售部 改為 市場部 ，就會遇到更新異常。

* 我們需要更新兩條記錄（E1 和 E2）才能反映這個變化。
* 如果只更新其中一條記錄，就會導致數據不一致，例如，E1 的部門是「市場部」，而 E2 的部門仍然是「銷售部」，但實際上他們應該在同一個部門。


**原因分析：**
這個問題的根源在於 `DeptManager` 部分依賴於 `EmpID`。
因為 `DeptManager` 由 `Dept` 決定，與具體的 `EmpID` 無關，所以將 `DeptManager` 放在這個表中會導致數據冗餘和更新異常。


reall: **table 中有兩個欄位關連，但其中一個又不具備唯一性 ->  redundancy **
就是上面的 `DeptManager` 和 `Dept`


**解決方案：**
为了解决这个问题，我们需要根据函数依赖关系对关系表进行分解，消除部分函数依赖关系。

可以将 `員工` 表分解为两个表：

* **`員工表`:** (EmpID, EmpName, Dept) 
* **`部門表`:** (Dept, DeptManager) 

這樣，每個部門負責人信息只會在 `部門表` 中存儲一次，避免了數據冗餘和更新異常。當需要更新部門負責人信息時，只需要更新 `部門表` 中的一條記錄即可。


**總結：**
通過分析函數依賴关系，我们可以识别出数据库设计中潜在的更新异常问题，并通过规范化技术对数据库进行优化，消除数据冗余，提高數據庫的完整性和一致性。 


