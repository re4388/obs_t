ref:  [我討厭 PostgreSQL 的 10 件事](https://rbranson.medium.com/10-things-i-hate-about-postgresql-20dbab8c2791)

### XID 會 wraparound(int, max is 4個億) and dead row → 寫大的 db, autovaum 沒做好 → gg
    
tx and all write ops are all have tx value called `XID`
但只有 32 位元, 約40億的 upper limit
超過就歸零
就會看到不該看的, 其實也不會看到
還差幾百萬, pg就禁止寫入，不過 db 這樣如同失效了, gg了

需要 vacuum 解決
pg 強的地方就是寫和讀互相不會 lock
利用其mvcc 機制
因為pg 的寫不是真的去改，update 不會真的去改，delete也沒有真的馬上去 delete
會出現 **dead row**
之後vacuum 再去處理

以上都要用 auto vacuum 或手動 vacuum, 解決
如果 db 有大量寫需求，又沒有把以上設定設定好，就會發上，然後就停機 gg 了。

==

wemo 最後是透過 application level, 把一些可能必要的對 rent 表和 box 表的寫操作進行優化
類似我們 update-box-msg, each bb call this API per min
and it will write into rent and box table 3-4 times per API
and we only need to do it one write per db -> refactor to solve it

### streaming replication 會掉資料（因為非同步）
    
- 先看 stream replica VS logical replica
	- stream replica, 直接寫入 write ahead log in binary format, 通常是作為高可用的用途
	- logical replica, 複製的是更高的抽象，類似 update, insert, 因此可以進行更多的控制, 因此還可以作為資料轉換, 選擇性replicate等等等		
- pg logical replication 的坑和限制([](https://www.notion.so/Mila-Computer-Calculus-RG-Reading-about-differential-integral-and-logical-calculi-32ebfdccdaef48aabccea29ecfb5dd8e?pvs=21)[https://www.postgresql.org/docs/12/logical-replication-restrictions.html](https://www.postgresql.org/docs/12/logical-replication-restrictions.html))
	- seq 不會處理 -> 需要自己 handle
	- DDL 不會帶過去  -> 需要自己手動 sync
	- only 一般的表 -> not include view, material table
	- parition 也不會， 還有一些要留意的，看 doc


### sync-replicate 相對複雜 且 影響效能比較多
- default 是 async-replicate, streaming
- 但如果掛了，一定會因為有些東西沒同步到 replicate 而導致數據流失


### pg 讀寫不互相lock的代價就是要確定 manmual/autovauccm 要弄好 (遇到大表又很多寫操作你就懂了, like wemo rent表)
    
- 相比之下，MySQL 和 Oracle 使用重做和撤消日誌。(redo log, fsync into hd)
	- So MySQL 不需要類似的後台垃圾收集過程。
	- but MySQL 的寫入成本是有事務提交和回滾操作的額外延遲。

### pg use process per conneciton (sql use thread per connection) → scale 最後會遇上極限，需要多一層，類似 [pgbouber](https://www.pgbouncer.org/) 層

- author use pgbouncer to setup another layer to handle 1 million connection
- *For more technical depth, see [https://brandur.org/postgres-connections.*](https://brandur.org/postgres-connections.*)
	- also see [[pg boucer]]

### pg index的 heap 結構很吃空間， 相比 mysql 有 secondray idx and oracle 的 idx-organized table
    
- 設計是希望更快的存取，少找了一層
- 但會占更大的空間，幾乎一倍

### 主版本升級可能要停機
    
- 因為底層 on-disk binary format 如果不兼容的話
- 還是可以做到，但是需要另外第三方的機制去處理
	- [Bucardo](https://bucardo.org/Bucardo/)
	- [PostgreSQL major version upgrade by using Logical Replication - CYBERTEC](https://www.cybertec-postgresql.com/en/upgrading-postgres-major-versions-using-logical-replication/)

### replica 的設置跟還是過於麻煩
    
- 雖然 mySql 原始設定 還是比較麻煩
- 但是更下面這些比，還是有很大的改進空間
	- mongoDB, redis, [my_sql的 group replicate](https://dev.mysql.com/doc/refman/8.0/en/group-replication.html), [galera](https://galeracluster.com/)


### pg 的sql 不支援 index-hint (就是無法指定用那個 idx 來 run sql)
    
- index-hint是一個功能，可以指定 query planer 要用那個 index
- pg 開發 team 認為，與其用 index hint, 不如好好寫 query


### mysql 有運用 block-compression的技術，psql這部份沒有做的很好 → 比較佔空間