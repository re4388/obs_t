
一般常見的 快取機制 cache aside, read/write through, write back, behind


可以用 
mater-slave 
and 
async-sync 兩個維度去看

- cache aside and read thru, 都是非同步把 db 的資料 replicate 到 cache (讀不到才會add 過去)
- write through 是同步確認兩者(db, cache) 都要寫入才會 ack
- write back/behind 就是把非同步的把 cache 資料非同步到 db



![[IMG-快取機制-20241119205211581.png|644]]



# Cache Aside

最常見的，因為通常不會需要 db <-> cache 間的"即時高一致需求"，也不想要"機率掉資料 at crash"

場景：
- 不需要即時高一致
- 高讀取性能 > 高寫入性能

重點：
- db 寫入就算成功，cache 是之後 async 處理(next step or 根本就不 update, set ttl, 下次 cache miss 再 update cache)


寫入
- 應用程序首先將數據寫入db，然後更新快取。


讀取
- 如果數據存在於快取中：直接從快取中讀取數據，並返回給應用程序。
- 如果數據不在快取中：從數據庫中讀取數據，然後將該數據寫入快取，以便未來的請求能夠直接從快取中獲取。
- 因為從 db 讀不到才會更新 cache, 因此 cache 的資料更新是 async

pro
- 最常見的 pattern
- 寫入 db 就算成功，因此寫入比 Read/Write Through 快
    

con
- 數據一致性問題：由於快取的更新是由應用程序控制的，因此可能會出現數據不一致的情況。例如，如果在寫入操作後未能正確更新快取，則下次讀取可能會獲得過期的數據。
    




# Read/Write Through

重點:
- cache and db 都寫入才算寫入成功

場景：
- 需要即時高一致
- 高讀取性能 > 高寫入性能

寫入
- 寫入操作：寫入時直接寫入緩存及資料庫，必須等到兩者都寫入成功才成功。
- 這樣可以確保快取和數據存儲中的數據始終保持一致。
- write 是 sync，所以會增加寫入延遲。


讀取
- 如果數據存在於快取中：直接從快取中讀取數據，並返回給應用程序，這樣可以顯著提高讀取性能。
- 如果數據不在快取中：系統會從 db 中讀取數據，然後將該數據寫入快取，並返回給應用程序。
- 應用程式都將只需面對緩存就好。
- 這一層看是套件還是自己做。
- read thru 是 async 是因為從 db 讀不到才會更新 cache, 因此 cache 的資料更新是 async

pro
- 數據一致性：由於每次寫入操作都會同步到底層數據存儲，這樣可以確保快取和數據存儲中的數據始終一致，減少了數據不一致的風險。
- 提高讀取性能：讀取操作通常能從快取中快速獲取數據，顯著提高系統的性能。

con
- 寫入延遲：在 Write Through 機制中，每次寫入都需要同時更新快取和底層存儲，這可能會導致寫入延遲，特別是在底層數據存儲性能較差的情況下。
- 性能瓶頸：在高寫入頻率的場景中，Write Through 可能會成為性能瓶頸，因為每次寫入都需要進行兩次操作。



example code
```js fold

const express = require('express');
const redis = require('redis');
const { promisify } = require('util');

const app = express();
const redisClient = redis.createClient();
const redisGetAsync = promisify(redisClient.get).bind(redisClient);
const redisSetAsync = promisify(redisClient.set).bind(redisClient);

// 中間件來解析 JSON 請求體
app.use(express.json());

// 讀取數據的 API
app.get('/data/:key', async (req, res) => {
    const key = req.params.key;

    // 嘗試從快取中獲取數據
    let data = await redisGetAsync(key);
    
    if (data) {
        // 如果快取中有數據，直接返回
        return res.status(200).send(JSON.parse(data));
    } else {
        // 如果快取中沒有數據，從數據庫獲取
        data = await fetchDataFromDatabase(key); // 假設這是一個從數據庫獲取數據的函數
        
        // 將數據寫入快取
        await redisSetAsync(key, JSON.stringify(data), 'EX', 3600); // 設置 TTL 為 3600 秒
        
        return res.status(200).send(data);
    }
});

// 寫入數據的 API
app.post('/data', async (req, res) => {
    const { key, value } = req.body;

    // 將數據寫入數據庫
    await writeDataToDatabase(key, value); // 假設這是一個寫入數據庫的函數

    // 將數據寫入快取
    await redisSetAsync(key, JSON.stringify(value), 'EX', 3600); // 設置 TTL 為 3600 秒

    return res.status(201).send({ message: 'Data saved successfully!' });
});

// 模擬從數據庫獲取數據
const fetchDataFromDatabase = async (key) => {
    // 在這裡實現實際的數據庫查詢邏輯
    return { key: key, value: 'some data from database' };
};

// 模擬寫入數據庫的函數
const writeDataToDatabase = async (key, value) => {
    // 在這裡實現實際的數據庫寫入邏輯
    console.log(`Writing to database: ${key} = ${value}`);
    // 假設寫入成功
};

// 啟動伺服器
const port = 3000;
app.listen(port, () => {
    console.log(`Server running at http://localhost:${port}`);
});

```



# Write behind Cache

重點：
- cache at front -> batch into db

場景：
- 高寫入性能 > 高讀取性能
- 低即時高一致 -> 可容忍低機率情況下(cache crash)掉資料

場景：
- 適合寫入多，因為這樣 cache 寫入就算結束!
- 但是除非有額外機制，會掉資料，因此場景需要可以容忍掉資料。

![[IMG-快取機制-20241119205211752.png]]
- 作法:
	- 把 cache 當做 master, db 當做 slave 來用
	- 數據更新只會 update cache，然後非同步的批次寫入 db
- pro
	- 對 db 的壓力更小
- con
	- 類似 db 上的資料如果會顯示在後台，可能就不適合。
	- 要可以接受 cache crash, but not batch into db yet, 這些資料會 lost
- 留意：
	- db and cache 資料不一致很高，場景要可以符合
	- 用在 未必一定要放在 db 的東西，不重要的 流水帳資料


- example
- 社交媒體平台經常需要處理大量的用戶互動（如點讚、評論等）。使用 Write-behind Cache，這些互動可以先寫入快取，然後在適當的時間批量寫入數據庫。這樣不僅能減少數據庫的即時負擔，還能提高用戶體驗，因為用戶的操作能夠迅速反饋。
- 類似的產品：[DyanmoDB DAX](https://aws.amazon.com/tw/dynamodbaccelerator/)


more: [极端事务处理模式：Write-behind缓存\_Java\_Lan Vuong\_InfoQ精选文章](https://www.infoq.cn/article/write-behind-caching)



上面是概念，可以組合使用。



ref:
- [什麼是快取 (Cache)？快取 (Cache) 的機制為何？｜ExplainThis](https://www.explainthis.io/zh-hant/swe/cache-mechanism)
- [淺談各種資料庫cache策略: cache aside、read through、write through、write back | HoMuChen](https://homuchen.com/posts/databse-chache-strategies/)


