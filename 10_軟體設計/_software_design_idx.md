





- [ ] [Lesson 157 - Incorporating ADRs Into Existing Systems (March 27, 2023)](https://www.developertoarchitect.com/lessons/lesson157.html "Lesson 157 - Incorporating ADRs Into Existing Systems (March 27, 2023)")
- [ ] [Lesson 156 - The Zachman Framework in 10 Minutes (March 13, 2023)](https://www.developertoarchitect.com/lessons/lesson156.html "Lesson 156 - The Zachman Framework in 10 Minutes (March 13, 2023)")
- [ ] [Lesson 155 - The Infinity Architecture AntiPattern (February 27, 2023)](https://www.developertoarchitect.com/lessons/lesson155.html "Lesson 155 - The Infinity Architecture AntiPattern (February 27, 2023)")
- [ ] [Lesson 153 - Service-Based Architecture vs. SOA (January 30, 2023)](https://www.developertoarchitect.com/lessons/lesson153.html "Lesson 153 - Service-Based Architecture vs. SOA (January 30, 2023)")
- [ ] [Lesson 152 - Modeling Distributed Workflows (January 16, 2023)](https://www.developertoarchitect.com/lessons/lesson152.html "Lesson 152 - Modeling Distributed Workflows (January 16, 2023)")
- [ ] [Lesson 149 - Caching and CAP Theorem (November 21, 2022)](https://www.developertoarchitect.com/lessons/lesson149.html "Lesson 149 - Caching and CAP Theorem (November 21, 2022)")
- [ ] [Lesson 141 - Managing Architecture Decisions (August 1, 2022)](https://www.developertoarchitect.com/lessons/lesson141.html "Lesson 141 - Managing Architecture Decisions (August 1, 2022)")
- [ ] [Lesson 140 - Governing Data Services (June 6, 2022)](https://www.developertoarchitect.com/lessons/lesson140.html "Lesson 140 - Governing Data Services (June 6, 2022)")
- [ ] [Lesson 130 - The Frozen Caveman AntiPattern (January 17, 2022)](https://www.developertoarchitect.com/lessons/lesson130.html "Lesson 130 - The Frozen Caveman AntiPattern (January 17, 2022)")
- [ ] [Lesson 129 - Assessing Architectural Risk (Part 3) (December 20, 2021)](https://www.developertoarchitect.com/lessons/lesson129.html "Lesson 129 - Assessing Architectural Risk (Part 3) (December 20, 2021)")
- [ ] [Lesson 128 - Assessing Architectural Risk (Part 2) (December 6, 2021)](https://www.developertoarchitect.com/lessons/lesson128.html "Lesson 128 - Assessing Architectural Risk (Part 2) (December 6, 2021)")
- [ ] [Lesson 127 - Assessing Architectural Risk (Part 1) (November 22, 2021)](https://www.developertoarchitect.com/lessons/lesson127.html "Lesson 127 - Assessing Architectural Risk (Part 1) (November 22, 2021)")
- [ ] [Lesson 126 - Is SOA Dead? (November 8, 2021)](https://www.developertoarchitect.com/lessons/lesson126.html "Lesson 126 - Is SOA Dead? (November 8, 2021)")
- [ ] [Lesson 125 - Managing Broad Bounded Contexts (October 25, 2021)](https://www.developertoarchitect.com/lessons/lesson125.html "Lesson 125 - Managing Broad Bounded Contexts (October 25, 2021)")
- [ ] [Lesson 124 - The Challenges of Distributed Architectures (October 11, 2021)](https://www.developertoarchitect.com/lessons/lesson124.html "Lesson 124 - The Challenges of Distributed Architectures (October 11, 2021)")
- [ ] [Lesson 123 - Composite Architecture Characteristics (September 27, 2021)](https://www.developertoarchitect.com/lessons/lesson123.html "Lesson 123 - Composite Architecture Characteristics (September 27, 2021)")
- [ ] [Lesson 122 - When Should You Replace Your Architecture? (September 13, 2021)](https://www.developertoarchitect.com/lessons/lesson122.html "Lesson 122 - When Should You Replace Your Architecture? (September 13, 2021)")



- [ ] [Software Architecture Monday | Developer to Architect | Mark Richards](https://www.developertoarchitect.com/lessons-microservices.html) 微服務系列
- [ ] [Software Architecture Monday | Developer to Architect | Mark Richards](https://www.developertoarchitect.com/lessons-eda.html) 事件驅動系列
- [ ] [Lesson 86 - Becoming A Software Architect (Part 1) (May 18, 2020) | Developer to Architect | Mark Richards](https://www.developertoarchitect.com/lessons/lesson86.html)
	- [ ] 和後面的 part







---
- [[Core Design Principles for Software Developers by Venkat Subramaniam]]
- [[Code Review, you said - Venkat Subramaniam]]
- [[Software Architecture The Hard Parts - Neal Ford]]
- [[Debugging Under Fire Keep your Head when Systems have Lost their Mind]]
- [[Continued Learning The Beauty of Maintenance - Kent Beck]] 
- [[Can Great Programmers Be Taught? - Prof. Dr. John Ousterhout]]
- [[How to Think Like an Architect - Mark Richards]]
- [[Thinking Like an Architect by Gregor Hohpe]]
- [[Build Abstractions Not Illusions by Gregor Hohpe]]
- [[agile]]
- [[how code rot]]
- [[abstract volatility away]]
- [[clean architecture]]
- [[OOP]]
- [[ DI 依賴反轉 and IoC 控制反轉]]
- [[非功能需求]]
- [[software design robust]]
- [[SOLID]]
- [[軟體設計 原子能]]
- [[unify vs 特化設計]]
- [[db vs app, 邏輯和loading要放哪裡]]
- [[发送时要保守，接收时要开放]]
- [[好莱坞原则（Hollywood Principles]]
- [[take more time to think about use case - this is everything]]
- [[Engineering Principles for Building Financial Systems]]
- [[why OOP? self-asking question]]
- [[性能生命周期（Performance Lifecycle）]]
- book
	- [nodeJS_design_pattern_book](https://www.notion.so/nture4388/nodeJS_design_pattern_book-f1a5791080ef48a5a736a13182bd04e1?pvs=4)
	- [refactoring martin fowler](https://www.notion.so/nture4388/refactoring-martin-fowler-f18019b736b44fc9b4f3f7e2fbb8da5d?pvs=4)
- wemo experience
	- [[core system 功能規劃記錄]]
	- [[分層架構 one repo per module]]
	- [[why use dto in nest.js response]]
	- other [notion note](https://www.notion.so/nture4388/better-design-1239df69750f8061836fc63324ce83dc?pvs=4)



---






[(778) What to do when there are no requirements - Uncle Bob - YouTube](https://www.youtube.com/watch?v=d2teQJzSh60)
- don't wait for the definition -> 開啟對話，先建立然後確認是否是這樣，你自己定義，讓他們確認是否可以


[(778) Why boolean arguments should be avoided - Robert C. Martin (Uncle Bob) - YouTube](https://www.youtube.com/watch?v=2Q9GRPxqCAk)
- 如果你 pass boolean to the function, you sould use 2 seperate fun



[Why you should never write bad code - Uncle Bob - YouTube](https://www.youtube.com/watch?v=HV1Kp-pj3fo)
- to move fast, you need to do it correctly -> 這代表很多時候你得慢下來，想清楚。


[(778) The problem with assignment statements - Uncle Bob - YouTube](https://www.youtube.com/watch?v=kdDDEHpS7ow)
- assert(f(x), f(x)) -> always true if f(x) is not side effect
- what is side effect?  if we have assignement statement in f(x) -> f(x)有可能有 side effect
- side effect function, will need another funciton to "undo" the side effect
	- like u have a funciton that open a file -> you need to have another fun to close the file
	- say you use malloc to allocate mem, u need to have another fun to de-allocate mem
- 另外 side effect 也跟 time coupling -> open need to before close, allocate mem need to first below de-allocate...etc



[The symptoms of bad code - Robert C. Martin (Uncle Bob) - YouTube](https://www.youtube.com/watch?v=vsQya8Ai1jw)
- 你改一個地方，你以為你只要改一個地方，沒想到很多地方都會連動到，因此你要去很多地方改
	- root cause: 沒有高內聚低耦合
	- solve: 
		- 假設你要調整價格系統的某個特定A功能的設定，應該就只有一個地方需要去調整。 
		- 沒關連的東西，不應該互相影響, 類似你改了 salaray 的計算，print report 的功能不應該不會被影響到
- common theme for bad code is "counping, 耦合", dependency





- [ ] [(604) 還在大費周章實作設計模式？一口氣了解函數型設計模式！與類別的設計有何區別？ - YouTube](https://www.youtube.com/watch?v=gFPVVKsDXdg)
	- [ ] try out use fn to implement factory and stgy



[(592) The code behind the Apollo moon landing ... was perfect - YouTube](https://www.youtube.com/watch?v=RnjTYBhAcfA)
key abt software design that transcand space and time
- oragnizing complex codebase
- **deisnging with user in mind**
- **optimizing resources**


[4 Software Design Principles I Learned the Hard Way](https://read.engineerscodex.com/p/4-software-design-principles-i-learned)
- reduce mutable state
- single source of truth
- don't blindly follow DRY => abstraction with clear intention
- don't over use mock -> not really understand how to actually do it...



# essential complexity
[A Note on Essential Complexity | olano.dev](https://olano.dev/blog/a-note-on-essential-complexity)
> In my experience most of the complexities which are encountered in systems work are symptoms of organizational malfunctions. Trying to model this reality with equally complex programs is actually to conserve the mess instead of solving the problems.

如果組織和spec本身就很亂，那"本質複雜性"(另一個意外複雜性，這個要盡可能降低)也會很亂
而這一點，工程師是可以去降低的，要降低的就是讓 spec 的架構更好

> 重新定義問題看起來像是作弊，但對資深工程師來說這只是平常事：我們為什麼要研究這個？我們真的需要它嗎？我們要解決什麼問題？我們解決這個問題對誰有利？如果我們最初發布的是 X1，而不是 X，這需要我們 20% 的努力並提供 80% 的功能，那會怎麼樣？



# 让编程再次伟大
[(540) 给代码起名字的三要三不要准则【让编程再次伟大 #11】 - YouTube](https://www.youtube.com/watch?v=Z02zGJcJ2EA&list=WL&index=2)
正確性 > 精準性 > 一致性





# 市场不会激励优秀的工程，它会激励速度和执行力
很多人觉得，代码质量是软件公司的生命。但是，大多数公司的生死存亡并不取决于它的代码库的质量。可怕的代码库也可能带来了数十亿美元的收入。市场不会激励优秀的工程，它会激励速度和执行力。
-- [《完美的代码库无法拯救你的公司》](https://www.catalystmonitor.com/blog/perfect-codebase-wont-save-your-company)



# to read
- [GitHub - zakirullin/cognitive-load: 🧠 Cognitive Load is what matters](https://github.com/zakirullin/cognitive-load)
- [99 Bottles — Sandi Metz](https://sandimetz.com/99bottles)
