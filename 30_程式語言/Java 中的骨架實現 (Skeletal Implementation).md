
骨架實現是介面的一種抽象類別實現，它提供了一些介面方法的預設實現，但仍然保留了一些抽象方法需要子類別去實現。這種模式也被稱為「抽象類別骨架」或「介面適配器」。

**目的：**

骨架實現的主要目的是簡化介面的實現。它提供了一些常用的預設方法實現，減少了子類別需要編寫的程式碼量。同時，它也保留了介面的靈活性，允許子類別根據需要覆寫預設方法或實現其他抽象方法。

**與抽象類別的關係：**

骨架實現通常以抽象類別的形式出現，它實現了介面，並提供了一些預設方法實現。子類別繼承這個抽象類別，並實現剩餘的抽象方法，即可完成介面的實現。

**例子：**

```java
// 介面
interface Animal {
    void eat();
    void sleep();
    void move();
}

// 骨架實現 (抽象類別)
abstract class AbstractAnimal implements Animal {
    @Override
    public void sleep() {
        System.out.println("Animal is sleeping");
    }

    // eat() 和 move() 仍然是抽象方法
}

// 具體實現
class Dog extends AbstractAnimal {
    @Override
    public void eat() {
        System.out.println("Dog is eating");
    }

    @Override
    public void move() {
        System.out.println("Dog is running");
    }
}

public class SkeletalImplementationExample {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.eat(); // 輸出 "Dog is eating"
        dog.sleep(); // 輸出 "Animal is sleeping"
        dog.move(); // 輸出 "Dog is running"
    }
}
```

**何時使用骨架實現：**

* **介面有多個方法，且部分方法有通用的預設實現：**  骨架實現可以提供這些預設實現，減少子類別的程式碼量。
* **希望在介面和具體實現之間提供一個中間層：**  骨架實現可以作為介面和具體實現之間的橋樑，提供一些額外的功能或約束。
* **簡化介面的實現：**  骨架實現可以使介面的實現更加容易，尤其是在介面方法較多的情況下。


**何時不應該使用骨架實現：**

* **介面方法很少，或者沒有通用的預設實現：**  在這種情況下，骨架實現的價值不大。
* **需要完全控制介面的實現：**  如果需要完全控制介面的實現，則不應該使用骨架實現，因為它會限制子類別的靈活性。
* **與介面預設方法衝突：**  如果介面已經使用了預設方法，則骨架實現可能會與預設方法產生衝突。  需要仔細考慮如何處理這些衝突。


**與介面預設方法的比較：**

* **介面預設方法：** 直接在介面中提供預設實現。
* **骨架實現：** 使用一個單獨的抽象類別來提供預設實現。

在 Java 8 及以後版本中，介面預設方法通常是比骨架實現更好的選擇，因為它們更直接、更簡潔。  但是，在某些情況下，骨架實現仍然有用，例如在需要提供額外的功能或約束，或者在需要與舊版本 Java 相容的情況下。


**總結：**

骨架實現是一種簡化介面實現的有效方式。它通過提供預設方法實現，減少了子類別需要編寫的程式碼量。  然而，在使用骨架實現時，需要仔細考慮其適用場景，並權衡其優缺點。  在 Java 8 及以後版本中，介面預設方法通常是比骨架實現更好的選擇。
