
 
 Effective 原文提到，"它们不依赖于易发生风险的语言外对象创建机制" 指的是 clone() 方法依赖于 Java 语言之外的机制，特别是 JVM 的原生方法 Object.clone()，来创建新的对象。这种机制有一些潜在的风险：
 
 `clone()` 方法依赖于 Java 语言之外的机制，特别是 JVM 的原生方法 `Object.clone()`，来创建新的对象。这种机制有一些潜在的风险：

1. **绕过构造函数:** **`clone()` 方法绕过了正常的构造函数调用。这意味着如果你的类有一些在构造函数中执行的重要初始化逻辑（例如，建立不变性、注册对象等**），这些逻辑在克隆过程中会被跳过，可能导致克隆对象处于不一致的状态。

2. **难以正确实现深拷贝:**  `Object.clone()` 执行的是浅拷贝。如果你的对象包含可变的引用类型成员，浅拷贝会导致原对象和克隆对象共享这些可变成员，从而产生潜在的错误。要实现深拷贝，你需要在 `clone()` 方法中手动复制所有可变的引用类型成员，这可能非常复杂且容易出错。  而拷贝构造函数或工厂方法可以显式地控制如何复制每个成员，更容易实现深拷贝。

3. **与 final 字段冲突:**  `clone()` 方法无法正确处理 `final` 字段。`final` 字段只能在构造函数中初始化一次。**由于 `clone()` 绕过了构造函数，它无法修改 `final` 字段的值，这可能导致克隆对象的状态与原对象不一致**。拷贝构造函数可以在初始化新对象时正确设置 `final` 字段的值。

4. **依赖 JVM 实现:** **`Object.clone()` 的具体行为依赖于 JVM 的实现。不同的 JVM 可能有不同的实现方式**，这可能会导致**代码的可移植性问题**。拷贝构造函数或工厂方法的行為則由 Java 代码明确定义，不依赖于 JVM 的具体实现。



"他们不要求无法强制执行的约定" 指的是使用 clone() 方法需要遵循一些约定，但这些约定无法在编译时强制执行，只能依靠开发者的自觉遵守。这增加了出错的风险。

具体来说，clone() 方法的约定包括：

1. **实现 Cloneable 接口:** 要使用 clone() 方法，类必须实现 Cloneable 接口。然而，Cloneable 是一个标记接口，它本身没有任何方法。编译器不会强制检查 clone() 方法的实现是否符合预期，只是检查类是否实现了 Cloneable。**如果没有实现，调用 clone() 会抛出 CloneNotSupportedException。但这并不能保证实现了 Cloneable 的类就一定正确地覆写了 clone() 方法。**
    
2. **正确覆写 clone () 方法:** 要创建一个功能正常的拷贝，类需要正确地覆写 clone() 方法，包括调用 super.clone() 和根据需要进行深拷贝。然而，编译器无法强制开发者这样做。开发者可能会忘记调用 super.clone()，或者没有正确地实现深拷贝，导致克隆对象的状态不正确。
    
3. **文档说明:** 开发者应该在文档中明确说明类的克隆行为，例如是浅拷贝还是深拷贝。但这同样无法强制执行，开发者可能会忘记编写文档，或者文档与实际行为不一致。


