Favor generic methods

Just as classes can be generic, so can methods. 

我們也要盡量讓 method 泛型化
基本上很多靜態方法都支持泛型
像是 All of the “algorithm” methods in Collections (such as binarySearch and sort) are generic.



### easy example

Consider this  method, which returns the union of two sets:
下面用 raw type, 我們來調整
![[IMG-Item30 优先使用泛型方法 v0-20241225153620451.png]]


This method compiles but with two warnings:
![[IMG-Item30 优先使用泛型方法 v0-20241225153620678.png]]


加上泛型
![[IMG-Item30 优先使用泛型方法 v0-20241225153620813.png]]


no err and no warning
下面是用法
![[IMG-Item30 优先使用泛型方法 v0-20241225153620920.png]]
When you run the program, it prints [Moe, Tom, Harry, Larry, Curly, Dick]. (The order of the elements in the output is implementation-dependent.)


這個 union method 的侷限是， input and ret type 都需要是一樣的 type
你如果要讓 method 更有彈性，可以用 bounded wildcard types (Item 31).




### generic singleton factory
有時候，你會想要建立一個object 是 immutable 但是可以吃很多不同的 type
我們可以利用 泛型 erasure (Item 28) 的特性，使用一個obj, 利用靜態工廠函數來針對每一個 type 參數持續性的來發放。
這叫做 generic singleton factory
this is used for function objects (Item 42) such as Collections.reverseOrder
and occasionally for collections such as Collections.emptySet.



假設你要寫一個 identity function dispenser
( The libraries provide Function.identity, so there’s no reason to write your own (Item 59), but it is instructive)




如果泛型是 reified (run-time info), 那每一個新的 identity f 都需要一個type
但是因為 泛型是 erased 的特性，你只需要共一個(a generic singleton will suffice)

![[IMG-Item30 优先使用泛型方法 v0-20241225153621029.png]]

這邊會需要 casting, 因為 `UnaryOperator<Object>` is not a `UnaryOperator<T>` for every T. 

但是沒差，因為identity function 的本質，什麼進來就什麼出去，因此一定是 typesafe 
Therefore, we can confidently suppress the unchecked cast warning generated by this cast


下面是用法，包括 a `UnaryOperator<String>` and a `UnaryOperator<Number>`
![[IMG-Item30 优先使用泛型方法 v0-20241225153621172.png]]




### Recursive type bounds

另一個很少見但允許的情況是，type參數 bouned by 自己構成的 expression
This is what’s known as a recursive type bound

 A common use of recursive type bounds is in connection with the Comparable interface, which defines a type’s natural ordering (Item 14). 

![[IMG-Item30 优先使用泛型方法 v0-20241225153621291.png]]

基本上，幾乎所有的type都是要跟自己比較。 So, for example, String implements `Comparable<String>`, Integer implements `Comparable<Integer>`, and so on.

很多函數都會吃 collection of element, 然後這些 element 實作 comparable 來進行 sort, search, 找最大最小等等

Here is how to express that constraint:
![[IMG-Item30 优先使用泛型方法 v0-20241225153621432.png]]

The type bound `<E extends Comparable<E>>` 這邊可以看成  "any type E 都可以跟自己比較"


下面是一個用這個函數宣告的函數，找出最大值
![[IMG-Item30 优先使用泛型方法 v0-20241225153621521.png]]
Note that this method throws IllegalArgumentException if the list is empty. A better alternative would be to return an `Optional<E> `(Item 55).

Recursive type bounds 可以非常複雜，不過應該不多。可以多了解 its wildcard variant (Item 31), and the simulated self-type idiom (Item 2) 來了解如何處理


### Summary
- generic methods, like generic types, are safer and easier to use than methods requiring their clients to put explicit casts on input parameters and return values. 
- Like types, you should make sure that your methods can be used without casts, which often means making them generic.
- And like types, you should generify existing methods whose use requires casts. This makes life easier for new users without breaking existing clients (Item 26).